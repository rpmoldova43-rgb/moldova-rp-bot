require('dotenv').config();
const fs = require('fs');
const path = require('path');

const {
  Client,
  GatewayIntentBits,
  SlashCommandBuilder,
  REST,
  Routes,
  PermissionFlagsBits,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  EmbedBuilder,
  UserSelectMenuBuilder,
} = require('discord.js');

const {
  DISCORD_TOKEN,
  CLIENT_ID,
  GUILD_ID,
  STAFF_ROLE_ID,
  WARN_CHANNEL_ID,
  WARN_FALLBACK_CATEGORY_ID,
  WARN_ROLE_1_ID,
  WARN_ROLE_2_ID,
  WARN_ROLE_3_ID,
  PANEL_CHANNEL_ID,
} = process.env;

if (!DISCORD_TOKEN || !CLIENT_ID || !GUILD_ID) {
  console.error('âŒ Lipsesc DISCORD_TOKEN / CLIENT_ID / GUILD_ID Ã®n .env');
  process.exit(1);
}

/* ================= CONFIG ================= */
const WARN_TTL_MS = 14 * 24 * 60 * 60 * 1000; // 14 zile
const TEMP_CHANNEL_TTL_MS = 24 * 60 * 60 * 1000; // 24 ore
const CLEANUP_EVERY_MS = 6 * 60 * 60 * 1000;

/* ================= FILES ================= */
const DATA_DIR = process.env.DATA_DIR || path.join(__dirname, 'data');
if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });

const WARN_FILE = path.join(DATA_DIR, 'warns.json');
const TEMP_FILE = path.join(DATA_DIR, 'temp_warn_channels.json');

/* ================= HELPERS ================= */
function isSnowflake(x) {
  return typeof x === 'string' && /^\d{17,20}$/.test(x);
}
function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

function isStaff(member) {
  return (
    (STAFF_ROLE_ID && member.roles.cache.has(STAFF_ROLE_ID)) ||
    member.permissions.has(PermissionFlagsBits.Administrator)
  );
}

/* ================= WARN DB (EXPIRING) ================= */
function loadWarnDB() {
  try {
    if (!fs.existsSync(WARN_FILE)) return {};
    return JSON.parse(fs.readFileSync(WARN_FILE, 'utf8'));
  } catch {
    return {};
  }
}

function saveWarnDB(db) {
  try {
    fs.writeFileSync(WARN_FILE, JSON.stringify(db, null, 2), 'utf8');
  } catch {}
}

function normalizeUserNode(node) {
  if (!node) return { entries: [] };

  // suport format vechi: [timestamp, timestamp, ...]
  if (Array.isArray(node)) {
    return { entries: node.map((ts) => ({ ts: Number(ts) || Date.now(), amount: 1 })) };
  }

  // format nou: { entries: [ {ts, amount}, ... ] }
  if (typeof node === 'object' && Array.isArray(node.entries)) {
    return { entries: node.entries };
  }

  return { entries: [] };
}

function pruneEntries(entries) {
  const now = Date.now();
  return (entries || []).filter(
    (e) =>
      e &&
      typeof e.ts === 'number' &&
      typeof e.amount === 'number' &&
      e.amount > 0 &&
      now - e.ts < WARN_TTL_MS
  );
}

function getWarnTotal(userId) {
  const db = loadWarnDB();
  db[userId] = normalizeUserNode(db[userId]);
  db[userId].entries = pruneEntries(db[userId].entries);

  const total = db[userId].entries.reduce((s, e) => s + (e.amount || 0), 0);
  if (total === 0) delete db[userId];
  saveWarnDB(db);
  return total;
}

function addWarnExpiring(userId, amount) {
  const db = loadWarnDB();
  db[userId] = normalizeUserNode(db[userId]);
  db[userId].entries = pruneEntries(db[userId].entries);

  db[userId].entries.push({ ts: Date.now(), amount });
  const total = db[userId].entries.reduce((s, e) => s + (e.amount || 0), 0);

  saveWarnDB(db);
  return total;
}

function removeWarnExpiring(userId, amount) {
  const db = loadWarnDB();
  db[userId] = normalizeUserNode(db[userId]);
  db[userId].entries = pruneEntries(db[userId].entries);

  let remaining = amount;

  // scoatem din cele mai noi Ã®nspre cele mai vechi
  for (let i = db[userId].entries.length - 1; i >= 0 && remaining > 0; i--) {
    const e = db[userId].entries[i];
    const take = Math.min(remaining, e.amount);
    e.amount -= take;
    remaining -= take;
    if (e.amount <= 0) db[userId].entries.splice(i, 1);
  }

  const total = db[userId].entries.reduce((s, e) => s + (e.amount || 0), 0);
  if (total === 0) delete db[userId];
  saveWarnDB(db);
  return total;
}

function cleanupAllExpiredWarns() {
  const db = loadWarnDB();
  let changed = false;

  for (const uid of Object.keys(db)) {
    db[uid] = normalizeUserNode(db[uid]);
    const before = db[uid].entries.length;
    db[uid].entries = pruneEntries(db[uid].entries);
    const after = db[uid].entries.length;

    if (before !== after) changed = true;

    const total = db[uid].entries.reduce((s, e) => s + (e.amount || 0), 0);
    if (total === 0) {
      delete db[uid];
      changed = true;
    }
  }

  if (changed) saveWarnDB(db);
}

/* ================= TEMP CHANNEL STORAGE ================= */
function readTemp() {
  try {
    if (!fs.existsSync(TEMP_FILE)) return [];
    return JSON.parse(fs.readFileSync(TEMP_FILE, 'utf8'));
  } catch {
    return [];
  }
}
function writeTemp(data) {
  try {
    fs.writeFileSync(TEMP_FILE, JSON.stringify(data, null, 2), 'utf8');
  } catch {}
}
function trackTempChannel(id, deleteAt) {
  const list = readTemp().filter((x) => x.id !== id);
  list.push({ id, deleteAt });
  writeTemp(list);
}
function untrackTempChannel(id) {
  writeTemp(readTemp().filter((x) => x.id !== id));
}
async function scheduleTempCleanup(guild) {
  const list = readTemp();
  for (const item of list) {
    const delay = item.deleteAt - Date.now();
    if (delay <= 0) {
      const ch = await guild.channels.fetch(item.id).catch(() => null);
      if (ch) await ch.delete('Auto-delete temp warn channel (expired)').catch(() => {});
      untrackTempChannel(item.id);
      continue;
    }
    setTimeout(async () => {
      const ch = await guild.channels.fetch(item.id).catch(() => null);
      if (ch) await ch.delete('Auto-delete temp warn channel (24h)').catch(() => {});
      untrackTempChannel(item.id);
    }, delay);
  }
}

/* ================= SANCTIONS ================= */
const SANCTIONS = [
  // ğŸ§  RP & COMPORTAMENT
  { key: 'frp', label: 'FRP', minutes: 30, extra: '' },
  { key: 'pg', label: 'PG', minutes: 45, extra: '' },
  { key: 'mg', label: 'MG', minutes: 30, extra: 'Warn' },
  { key: 'nf', label: 'No-Fear (NF)', minutes: 60, extra: 'Warn' },
  { key: 'cop_fear', label: 'Cop Fear', minutes: 30, extra: '' },
  { key: 'cop_bait', label: 'Cop Baiting', minutes: 30, extra: '' },
  { key: 'refuz_rp', label: 'Refuz RP', minutes: 30, extra: '' },
  { key: 'dc_rp', label: 'Disconnect Ã®n RP', minutes: 90, extra: 'Warn' },
  { key: 'mixing', label: 'Mixing (IC/OOC)', minutes: 30, extra: '' },
  { key: 'ooc_ic', label: 'OOC Ã®n IC', minutes: 45, extra: 'Warn' },
  { key: 'provoking', label: 'Provoking', minutes: 30, extra: '' },
  { key: 'post_hunt', label: 'Post Hunting', minutes: 45, extra: 'Warn' },
  { key: 'rk', label: 'Revenge Kill (RK)', minutes: 60, extra: 'Warn' },
  { key: 'pk', label: 'PK', minutes: 60, extra: 'Warn' },

  // ğŸ”« COMBAT
  { key: 'dm', label: 'DM', minutes: 30, extra: '' },
  { key: 'rdm', label: 'RDM', minutes: 60, extra: 'Warn' },
  { key: 'vdm', label: 'VDM', minutes: 45, extra: 'Warn' },
  { key: 'rob_kill', label: 'Rob&Kill', minutes: 60, extra: 'Warn' },
  { key: 'kamikaze', label: 'Kamikaze', minutes: 60, extra: 'Warn' },
  { key: 'car_ram', label: 'Car-Ram', minutes: 60, extra: '' },
  { key: 'chicken', label: 'Chicken Run', minutes: 30, extra: 'Warn' },
  { key: 'hq_gang', label: 'Atac HQ gang', minutes: 60, extra: 'Warn' },

  // ğŸ§â€â™‚ï¸ NON-RP / ABUZ
  { key: 'rs', label: 'RS', minutes: 150, extra: 'Warn' },
  { key: 'olympic', label: 'Olympic Swim', minutes: 45, extra: '' },
  { key: 'nj', label: 'Ninja Jack', minutes: 30, extra: '' },
  { key: 'safezone', label: 'Safe-Zone', minutes: 90, extra: 'Warn' },
  { key: 'jef_mort', label: 'Jefuire pe mort', minutes: 90, extra: 'Warn' },
  { key: 'inv_mort', label: 'Inventar pe mort', minutes: 90, extra: 'Warn' },

  // ğŸ BUG & META GRAV
  { key: 'bug_abuse', label: 'Bug Abuse', minutes: 120, extra: '2 Warn' },
  { key: 'meta_discord', label: 'Meta grav', minutes: 120, extra: '2 Warn' },

  // ğŸ­ TROLLING / TOXIC
  { key: 'trolling', label: 'Trolling', minutes: 120, extra: '2 Warn' },
  { key: 'inj_staff', label: 'Ãnj. Staff', minutes: 120, extra: '' },
  { key: 'oftic_ticket', label: 'OfticÄƒri ticket', minutes: 30, extra: 'Warn' },
  { key: 'inj_ticket', label: 'Ãnj. ticket', minutes: 45, extra: 'Warn' },
  { key: 'ticket_rp', label: 'Ticket Ã®n RP', minutes: 40, extra: '' },

  // ğŸ“º MEDIA
  { key: 'stream_snipe', label: 'Stream-Snipe', minutes: 180, extra: '2 Warn' },

  // ğŸš” ILEGAL
  { key: 'ilegal_public', label: 'Ilegal public', minutes: 30, extra: '' },
  { key: 'ilegal_fara_masca', label: 'Ilegal fÄƒrÄƒ mascÄƒ', minutes: 25, extra: '' },
  { key: 'arme_neaut', label: 'Arme neaut.', minutes: 30, extra: '' },

  // ğŸ§‘â€ğŸ’¼ ABUZ FUNCÈšIE
  { key: 'abuz_grad', label: 'Abuz de grad', minutes: 25, extra: '' },
  { key: 'ostatic_factie', label: 'Ostatic facÈ›iune', minutes: 20, extra: '' },
];

const BY_KEY = new Map(SANCTIONS.map((s) => [s.key, s]));

function parseWarn(extra) {
  if (!extra) return 0;
  if (extra.includes('2 Warn')) return 2;
  if (extra.includes('Warn')) return 1;
  return 0;
}

/* ================= MAIN (BUTONE ROÈ˜II) ================= */
const MAIN_KEYS = new Set([
  'frp', 'pg', 'mg', 'nf', 'dc_rp', 'rk', 'pk',
  'dm', 'rdm', 'vdm', 'rob_kill', 'kamikaze', 'car_ram',
]);

/* ================= WARN ROLES ================= */
function pickWarnRoleId(totalWarn) {
  if (totalWarn >= 3) return WARN_ROLE_3_ID || null;
  if (totalWarn === 2) return WARN_ROLE_2_ID || null;
  if (totalWarn === 1) return WARN_ROLE_1_ID || null;
  return null;
}

async function syncWarnRoles(guild, userId, totalWarn) {
  const member = await guild.members.fetch(userId).catch(() => null);
  if (!member) return { ok: false, applied: null };

  const warnRoleIds = [WARN_ROLE_1_ID, WARN_ROLE_2_ID, WARN_ROLE_3_ID].filter(Boolean);
  const targetRole = pickWarnRoleId(totalWarn);

  const toRemove = warnRoleIds.filter((rid) => member.roles.cache.has(rid));
  if (toRemove.length) await member.roles.remove(toRemove, 'Sync warn roles').catch(() => {});

  if (!targetRole) return { ok: true, applied: null };

  const ok = await member.roles.add(targetRole, 'Auto warn role').then(() => true).catch(() => false);
  return { ok, applied: targetRole };
}

/* ================= EMBEDS ================= */
function buildWarnEmbedMulti({ targetUser, totalMinutes, warnAdd, totalWarn, sanctionsText, staffUser }) {
  return new EmbedBuilder()
    .setColor(0xff0000)
    .setTitle('âš ï¸ SancÈ›iune aplicatÄƒ')
    .setDescription(`ğŸ‘¤ PersoanÄƒ: <@${targetUser.id}>`)
    .addFields(
      { name: 'ÃncÄƒlcÄƒri aplicate', value: sanctionsText, inline: false },
      { name: 'Total DEMORGAN', value: `${totalMinutes} minute`, inline: true },
      { name: 'Warn aplicat', value: `+${warnAdd}`, inline: true },
      { name: 'Total warnuri', value: `${totalWarn}`, inline: true },
      { name: 'ğŸ”´ Aplicat de', value: `<@${staffUser.id}>`, inline: false },
    )
    .setFooter({ text: 'Staff Moldova RP' })
    .setTimestamp(new Date());
}

/* ================= LOG + DM + FALLBACK ================= */
async function sendWarnLogDMAndFallback({ guild, targetUser, embed }) {
  // #warn
  if (isSnowflake(WARN_CHANNEL_ID)) {
    const warnChannel = await guild.channels.fetch(WARN_CHANNEL_ID).catch(() => null);
    if (warnChannel && warnChannel.isTextBased()) {
      await warnChannel.send({ content: `<@${targetUser.id}>`, embeds: [embed] }).catch(() => {});
    }
  }

  // DM
  const dmOk = await targetUser.send({ embeds: [embed] }).then(() => true).catch(() => false);

  // fallback canal 24h
  if (!dmOk) {
    const safeName = (targetUser.username || 'user')
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/(^-|-$)/g, '')
      .slice(0, 20);

    const ch = await guild.channels
      .create({
        name: `warn-${safeName}-${targetUser.id.slice(-4)}`.slice(0, 95),
        type: 0,
        parent: isSnowflake(WARN_FALLBACK_CATEGORY_ID) ? WARN_FALLBACK_CATEGORY_ID : null,
        permissionOverwrites: [
          { id: guild.roles.everyone.id, deny: ['ViewChannel'] },
          { id: targetUser.id, allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory'] },
          ...(isSnowflake(STAFF_ROLE_ID)
            ? [{ id: STAFF_ROLE_ID, allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory'] }]
            : []),
          { id: guild.members.me.id, allow: ['ViewChannel', 'SendMessages', 'ReadMessageHistory', 'ManageChannels'] },
        ],
        reason: 'Warn DM fallback (auto-delete 24h)',
      })
      .catch(() => null);

    if (ch) {
      await ch
        .send({
          content: `ğŸ”’ **DM privat/blocat** â€“ canal temporar (se È™terge Ã®n 24h)\nPersoanÄƒ: <@${targetUser.id}>`,
          embeds: [embed],
        })
        .catch(() => {});

      const deleteAt = Date.now() + TEMP_CHANNEL_TTL_MS;
      trackTempChannel(ch.id, deleteAt);

      setTimeout(async () => {
        const channel = await guild.channels.fetch(ch.id).catch(() => null);
        if (channel) await channel.delete('Auto-delete temp warn channel (24h)').catch(() => {});
        untrackTempChannel(ch.id);
      }, TEMP_CHANNEL_TTL_MS);
    }
  }
}

/* ================= PANEL (BUTONE) ================= */
function buildButtonsGrid(list, prefix) {
  const rows = [];
  let current = [];

  for (const s of list) {
    const style = MAIN_KEYS.has(s.key) ? ButtonStyle.Danger : ButtonStyle.Secondary;

    const btn = new ButtonBuilder()
      .setCustomId(`${prefix}:${s.key}`)
      .setLabel(s.label)
      .setStyle(style);

    current.push(btn);

    if (current.length === 5) {
      rows.push(new ActionRowBuilder().addComponents(current));
      current = [];
    }
  }

  if (current.length) rows.push(new ActionRowBuilder().addComponents(current));
  return rows;
}

function buildPanelMessage(title, desc, list, prefix, color) {
  const embed = new EmbedBuilder()
    .setColor(color)
    .setTitle(title)
    .setDescription(desc)
    .setFooter({ text: 'Moldova RP â€¢ Staff Panel' });

  const rows = buildButtonsGrid(list, prefix);
  return { embeds: [embed], components: rows.slice(0, 5) };
}

function chunk(array, size) {
  const out = [];
  for (let i = 0; i < array.length; i += size) out.push(array.slice(i, i + size));
  return out;
}

/* ================= CART (multi din butoane) ================= */
const cartState = new Map(); // staffId -> { targetId, selected:Set }
const cartMsgId = new Map(); // staffId -> true (existÄƒ un ephemeral activ)
const cartUi = new Map(); 
// staffId -> { threadId: string, messageId: string }

async function getOrCreateCartThread(guild, staffMember) {
  const panelChannelId = isSnowflake(PANEL_CHANNEL_ID) ? PANEL_CHANNEL_ID : staffMember.guild.systemChannelId;
  const panelCh = await guild.channels.fetch(panelChannelId).catch(() => null);
  if (!panelCh || !panelCh.isTextBased()) return null;

  const name = `cos-sanctiuni-${staffMember.user.username}`.toLowerCase().replace(/[^a-z0-9-]/g, '-').slice(0, 50);

  // dacÄƒ existÄƒ deja Ã®n map, Ã®ncercÄƒm fetch
  const saved = cartUi.get(staffMember.id);
  if (saved?.threadId) {
    const th = await guild.channels.fetch(saved.threadId).catch(() => null);
    if (th && th.isThread()) return th;
  }

  // creÄƒm thread privat (vizibil doar celor adÄƒugaÈ›i)
  const thread = await panelCh.threads.create({
    name,
    autoArchiveDuration: 1440, // 24h
    type: 12, // PrivateThread
    invitable: false,
    reason: 'CoÈ™ sancÈ›iuni (panel)',
  }).catch(() => null);

  if (!thread) return null;

  // adÄƒugÄƒm staff Ã®n thread
  await thread.members.add(staffMember.id).catch(() => {});
  cartUi.set(staffMember.id, { threadId: thread.id, messageId: null });

  return thread;
}

async function upsertCartMessage(thread, staffId, payload) {
  const saved = cartUi.get(staffId);

  if (saved?.messageId) {
    const msg = await thread.messages.fetch(saved.messageId).catch(() => null);
    if (msg) {
      await msg.edit(payload).catch(() => {});
      return msg;
    }
  }

  const sent = await thread.send(payload).catch(() => null);
  if (sent) cartUi.set(staffId, { threadId: thread.id, messageId: sent.id });
  return sent;
}

function getCart(staffId) {
  const st = cartState.get(staffId) || { targetId: null, selected: new Set() };
  cartState.set(staffId, st);
  return st;
}

function calcCart(selectedKeys) {
  const sanctions = selectedKeys.map((k) => BY_KEY.get(k)).filter(Boolean);
  const totalMinutes = sanctions.reduce((sum, s) => sum + (s.minutes || 0), 0);
  const totalWarnAdd = sanctions.reduce((sum, s) => sum + parseWarn(s.extra), 0);
  return { sanctions, totalMinutes, totalWarnAdd };
}

function buildCartPayload(staffId) {
  const st = getCart(staffId);
  const keys = Array.from(st.selected).slice(0, 10);
  const { sanctions, totalMinutes, totalWarnAdd } = calcCart(keys);

  const listText = sanctions.length
    ? sanctions
        .map((s) => `â€¢ ${s.label} (${s.minutes}m${s.extra ? ` + ${s.extra}` : ''})`)
        .join('\n')
        .slice(0, 1000)
    : 'â€”';

  const embed = new EmbedBuilder()
    .setColor(0x3498db)
    .setTitle('ğŸ§¾ SancÈ›iuni selectate (din butoane)')
    .setDescription(
      `ğŸ‘¤ PersoanÄƒ: ${st.targetId ? `<@${st.targetId}>` : '**Alege persoana**'}\n` +
      `ğŸ“Œ Selectate: **${keys.length}/10**\n` +
      `â±ï¸ Total DEMORGAN: **${totalMinutes} min**\n` +
      `âš ï¸ Total WARN: **+${totalWarnAdd}**`
    )
    .addFields({ name: 'ÃncÄƒlcÄƒri', value: listText, inline: false })
    .setFooter({ text: 'Moldova RP â€¢ Staff Cart' });

  const userRow = new ActionRowBuilder().addComponents(
    new UserSelectMenuBuilder()
      .setCustomId('cart:user')
      .setPlaceholder('Alege persoana...')
      .setMinValues(1)
      .setMaxValues(1)
  );

  const btnRow = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId('cart:apply').setLabel('âœ… AplicÄƒ').setStyle(ButtonStyle.Success),
    new ButtonBuilder().setCustomId('cart:clear').setLabel('ğŸ§¹ Reset').setStyle(ButtonStyle.Secondary)
  );

  return { embeds: [embed], components: [userRow, btnRow] };
}

/* ================= DISCORD CLIENT ================= */
const client = new Client({ intents: [GatewayIntentBits.Guilds] });

/* ================= COMMANDS ================= */
async function registerCommands() {
  const commands = [
    new SlashCommandBuilder().setName('panel').setDescription('Trimite panel sancÈ›iuni (butoane)'),
    new SlashCommandBuilder()
      .setName('warns')
      .setDescription('AratÄƒ cÃ¢te warnuri active are un user (expirÄƒ dupÄƒ 14 zile)')
      .addUserOption((o) => o.setName('user').setRequired(true).setDescription('User Discord')),
    new SlashCommandBuilder()
      .setName('unwarn')
      .setDescription('Scoate warnuri de la un user (default 1)')
      .addUserOption((o) => o.setName('user').setRequired(true).setDescription('User Discord'))
      .addIntegerOption((o) =>
        o.setName('amount').setMinValue(1).setRequired(false).setDescription('CÃ¢te warnuri scoÈ›i')
      ),
  ].map((c) => c.toJSON());

  const rest = new REST({ version: '10' }).setToken(DISCORD_TOKEN);
  await rest.put(Routes.applicationGuildCommands(CLIENT_ID, GUILD_ID), { body: commands });
}

/* ================= READY ================= */
client.once('ready', async () => {
  console.log(`ğŸ¤– Logged in as ${client.user.tag}`);

  await registerCommands();

  const guild = await client.guilds.fetch(GUILD_ID).catch(() => null);
  if (guild) await scheduleTempCleanup(guild);

  cleanupAllExpiredWarns();
  setInterval(() => cleanupAllExpiredWarns(), CLEANUP_EVERY_MS);
});

/* ================= INTERACTIONS ================= */
client.on('interactionCreate', async (interaction) => {
  try {
    /* ---------- SLASH COMMANDS ---------- */
    if (interaction.isChatInputCommand()) {
      if (interaction.commandName === 'panel') {
        if (!isStaff(interaction.member))
          return interaction.reply({ content: 'â›” Nu ai permisiune.', ephemeral: true });

        const mainList = SANCTIONS.filter((s) => MAIN_KEYS.has(s.key));
        const mainChunks = chunk(mainList, 25);

        const extraList = SANCTIONS.filter((s) => !MAIN_KEYS.has(s.key));
        const extraChunks = chunk(extraList, 25);

        let channel = interaction.channel;
        if (isSnowflake(PANEL_CHANNEL_ID)) {
          const ch = await interaction.guild.channels.fetch(PANEL_CHANNEL_ID).catch(() => null);
          if (ch && ch.isTextBased()) channel = ch;
        }

        for (let i = 0; i < mainChunks.length; i++) {
          const msg = buildPanelMessage(
            i === 0
              ? 'ğŸš¨ SancÈ›iuni principale (Rapid)'
              : `ğŸš¨ SancÈ›iuni principale (Rapid) ${i + 1}/${mainChunks.length}`,
            'ApasÄƒ sancÈ›iunile (max 10). DupÄƒ asta, Ã®n coÈ™ alegi persoana È™i apeÈ™i **AplicÄƒ**.\nButoanele ROÈ˜II = principale.\nWarnurile expirÄƒ dupÄƒ 14 zile.',
            mainChunks[i],
            's',
            0xff0000
          );
          await channel.send(msg);
        }

        for (let i = 0; i < extraChunks.length; i++) {
          const msg = buildPanelMessage(
            i === 0 ? 'ğŸ“Œ Alte sancÈ›iuni' : `ğŸ“Œ Alte sancÈ›iuni ${i + 1}/${extraChunks.length}`,
            'DacÄƒ nu gÄƒseÈ™ti sancÈ›iunea Ã®n principale, foloseÈ™te aici. (max 10 selectate)',
            extraChunks[i],
            's',
            0x3498db
          );
          await channel.send(msg);
        }

        return interaction.reply({ content: 'âœ… Panel trimis.', ephemeral: true });
      }

      if (interaction.commandName === 'warns') {
        if (!isStaff(interaction.member))
          return interaction.reply({ content: 'â›” Nu ai permisiune.', ephemeral: true });

        const user = interaction.options.getUser('user', true);
        const total = getWarnTotal(user.id);

        const roleRes = await syncWarnRoles(interaction.guild, user.id, total);
        const roleText = roleRes.applied ? `<@&${roleRes.applied}>` : 'niciun rol';

        const embed = new EmbedBuilder()
          .setColor(0xf1c40f)
          .setTitle('ğŸ“Œ Warnuri active')
          .setDescription(`PersoanÄƒ: <@${user.id}>`)
          .addFields(
            { name: 'Total warnuri active', value: `${total}`, inline: true },
            { name: 'Rol warn', value: `${roleText}`, inline: true },
            { name: 'Expirare', value: 'Automat dupÄƒ **14 zile**', inline: false }
          )
          .setTimestamp(new Date());

        return interaction.reply({ embeds: [embed], ephemeral: true });
      }

      if (interaction.commandName === 'unwarn') {
        if (!isStaff(interaction.member))
          return interaction.reply({ content: 'â›” Nu ai permisiune.', ephemeral: true });

        const user = interaction.options.getUser('user', true);
        const amount = interaction.options.getInteger('amount') ?? 1;

        const before = getWarnTotal(user.id);
        const after = removeWarnExpiring(user.id, amount);

        const roleRes = await syncWarnRoles(interaction.guild, user.id, after);
        const roleText = roleRes.applied ? `<@&${roleRes.applied}>` : 'niciun rol';

        const embed = new EmbedBuilder()
          .setColor(0x9b59b6)
          .setTitle('ğŸ§¹ Unwarn aplicat')
          .setDescription(`PersoanÄƒ: <@${user.id}>`)
          .addFields(
            { name: 'Ãnainte', value: `${before}`, inline: true },
            { name: 'Scos', value: `-${Math.min(amount, before)}`, inline: true },
            { name: 'DupÄƒ', value: `${after}`, inline: true },
            { name: 'Rol warn', value: `${roleText}`, inline: false },
            { name: 'Aplicat de', value: `<@${interaction.user.id}>`, inline: false }
          )
          .setTimestamp(new Date());

        return interaction.reply({ embeds: [embed], ephemeral: true });
      }
    }

      /* ---------- CLICK PE SANCÈšIUNE (PANEL RÄ‚MÃ‚NE, COÈ˜UL SE UPDATEAZÄ‚ ÃN THREAD) ---------- */
      if (interaction.isButton() && interaction.customId.startsWith('s:')) {
        if (!isStaff(interaction.member))
          return interaction.reply({ content: 'â›” Nu ai permisiune.', ephemeral: true });

        await interaction.deferUpdate(); // nu modificÄƒm mesajul panelului

        const key = interaction.customId.split(':')[1];
        const sanction = BY_KEY.get(key);
        if (!sanction) return;

        const st = getCart(interaction.user.id);

        // toggle
        if (st.selected.has(key)) st.selected.delete(key);
        else st.selected.add(key);

        // limitÄƒ 10
        const arr = Array.from(st.selected);
        if (arr.length > 10) st.selected = new Set(arr.slice(0, 10));

        const thread = await getOrCreateCartThread(interaction.guild, interaction.member);
        if (!thread) return;

        const payload = buildCartPayload(interaction.user.id);
        await upsertCartMessage(thread, interaction.user.id, payload);

        // opÈ›ional: mic ping Ã®n ephemeral ca sÄƒ È™tii unde e coÈ™ul
        // (dacÄƒ nu vrei mesaj, È™terge blocul de mai jos)
        try {
          await interaction.followUp({ content: `ğŸ§¾ CoÈ™ actualizat Ã®n thread: <#${thread.id}>`, ephemeral: true });
        } catch {}
      }

    /* ---------- CART: SELECT USER (Ã®n acelaÈ™i coÈ™) ---------- */
    if (interaction.isUserSelectMenu() && interaction.customId === 'cart:user') {
      if (!isStaff(interaction.member))
        return interaction.reply({ content: 'â›” Nu ai permisiune.', ephemeral: true });

      const st = getCart(interaction.user.id);
      st.targetId = interaction.values[0];

      // update editeazÄƒ mesajul ephemeral
      cartMsgId.set(interaction.user.id, true);
      return interaction.update(buildCartPayload(interaction.user.id));
    }

    /* ---------- CART: APPLY / CLEAR ---------- */
    if (interaction.isButton() && interaction.customId.startsWith('cart:')) {
      if (!isStaff(interaction.member))
        return interaction.reply({ content: 'â›” Nu ai permisiune.', ephemeral: true });

      const st = getCart(interaction.user.id);

      if (interaction.customId === 'cart:clear') {
        st.selected = new Set();
        cartMsgId.set(interaction.user.id, true);
        return interaction.update(buildCartPayload(interaction.user.id));
      }

      if (interaction.customId === 'cart:apply') {
        if (!st.targetId)
          return interaction.reply({ content: 'âš ï¸ Alege persoana mai Ã®ntÃ¢i.', ephemeral: true });

        const keys = Array.from(st.selected).slice(0, 10);
        if (keys.length === 0)
          return interaction.reply({ content: 'âš ï¸ SelecteazÄƒ cel puÈ›in o Ã®ncÄƒlcare (apasÄƒ butoanele).', ephemeral: true });

        const targetUser = await client.users.fetch(st.targetId).catch(() => null);
        if (!targetUser) return interaction.reply({ content: 'âš ï¸ Nu pot gÄƒsi user-ul.', ephemeral: true });

        const { sanctions, totalMinutes, totalWarnAdd: warnAdd } = calcCart(keys);

        let totalWarn = getWarnTotal(targetUser.id);
        let roleApplied = null;

        if (warnAdd > 0) {
          totalWarn = addWarnExpiring(targetUser.id, warnAdd);
          const roleRes = await syncWarnRoles(interaction.guild, targetUser.id, totalWarn);
          roleApplied = roleRes.applied;

          const sanctionsText = sanctions
            .map((s) => `â€¢ ${s.label} (${s.minutes}m${s.extra ? ` + ${s.extra}` : ''})`)
            .join('\n')
            .slice(0, 1000);

          const embedLog = buildWarnEmbedMulti({
            targetUser,
            totalMinutes,
            warnAdd,
            totalWarn,
            sanctionsText,
            staffUser: interaction.user,
          });

          await sendWarnLogDMAndFallback({ guild: interaction.guild, targetUser, embed: embedLog });
        } else {
          const roleRes = await syncWarnRoles(interaction.guild, targetUser.id, totalWarn);
          roleApplied = roleRes.applied;
        }

        const roleText = roleApplied ? `<@&${roleApplied}>` : 'niciun rol';

        // confirmare Ã®n acelaÈ™i coÈ™ (nu mesaj nou)
        const confirm = new EmbedBuilder()
          .setColor(0x2ecc71)
          .setTitle('âœ… Aplicat')
          .setDescription(`ğŸ‘¤ PersoanÄƒ: <@${targetUser.id}>`)
          .addFields(
            { name: 'ÃncÄƒlcÄƒri', value: sanctions.map((s) => `â€¢ ${s.label}`).join('\n').slice(0, 1000), inline: false },
            { name: 'Total DEMORGAN', value: `${totalMinutes} minute`, inline: true },
            { name: 'Warn', value: `+${warnAdd} (total activ: ${totalWarn})`, inline: true },
            { name: 'Rol warn', value: `${roleText}`, inline: true },
            { name: 'Aplicat de', value: `<@${interaction.user.id}>`, inline: false }
          )
          .setTimestamp(new Date());

        // reset coÈ™ dupÄƒ aplicare
        st.selected = new Set();

        cartMsgId.set(interaction.user.id, true);
        // confirmare Ã®n coÈ™
        await interaction.update({ embeds: [confirm], components: [] });

        // dupÄƒ 10 secunde: È™terge mesajul coÈ™ + thread
        await sleep(10_000);

        const msgToDelete = interaction.message; // mesajul din thread pe care ai apÄƒsat
        await msgToDelete.delete().catch(() => {});

        // dacÄƒ vrei sÄƒ È™teargÄƒ È™i thread-ul (RECOMANDAT)
        const th = interaction.channel;
        if (th && th.isThread()) {
          await th.delete('Auto-delete cart thread after apply').catch(() => {});
        }

        return;
              }
            }
  } catch (e) {
    console.error(e);
    if (interaction.isRepliable()) {
      try {
        await interaction.reply({ content: 'âš ï¸ Eroare internÄƒ.', ephemeral: true });
      } catch {}
    }
  }
});

client.login(DISCORD_TOKEN);
